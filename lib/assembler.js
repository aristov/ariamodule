import { DocumentAssembler, ElementAssembler } from 'dommodule'

const { assign } = Object

const XHTML_NAMESPACE_URI = 'http://www.w3.org/1999/xhtml'
const DEFAULT_HTML_DOCUMENT_NAME = 'html'
const DEFAULT_HTML_ELEMENT_NAME = 'span'
const DEFAULT_HTML_TITLE = 'No title'

export class HTMLDocumentAssembler extends DocumentAssembler {
    /**
     * @param {HTMLElement} activeElement
     */
    set activeElement(activeElement) {
        if(this.node.contains(activeElement)) {
            activeElement.focus()
        }
    }

    /**
     * @returns {HTMLElement}
     */
    get activeElement() {
        return this.node.activeElement
    }
    /**
     * @param {String} title
     */
    set title(title) {
        this.node.title = title
    }

    /**
     * @returns {String}
     */
    get title() {
        return this.node.title
    }

    /**
     * @param {HTMLHeadElement} head
     */
    set head(head) {
        const element = this.head
        if(element) element.replaceWith(head)
        else this.documentElement.prepend(head)
    }

    /**
     * @returns {HTMLHeadElement}
     */
    get head() {
        return this.node.head
    }

    /**
     * @param {HTMLBodyElement} body
     */
    set body(body) {
        this.node.body = body
    }

    /**
     * @returns {HTMLBodyElement}
     */
    get body() {
        return this.node.body
    }

    /**
     * @param {String} title
     * @returns {HTMLDocument}
     */
    static create({ title = this.title } = this) {
        return this.implementation.createHTMLDocument(title)
    }

    /**
     *
     * @returns {String}
     */
    static get namespaceURI() {
        return XHTML_NAMESPACE_URI
    }

    /**
     * @returns {String}
     */
    static get localName() {
        return DEFAULT_HTML_DOCUMENT_NAME
    }

    /**
     * @returns {String}
     */
    static get title() {
        return DEFAULT_HTML_TITLE
    }
}

/*================================================================*/

export class HTMLElementAssembler extends ElementAssembler {
    emit(eventType) {
        const event = new CustomEvent(eventType, {
            bubbles : true,
            cancelable : true
        })
        this.node.dispatchEvent(event)
    }

    set dataset(dataset) {
        assign(this.node.dataset, dataset)
    }

    get dataset() {
        return this.node.dataset
    }

    set style(style) {
        assign(this.node.style, style)
    }

    get style() {
        return this.node.style
    }

    set tabIndex(tabIndex) {
        this.node.tabIndex = tabIndex
    }

    get tabIndex() {
        const node = this.node
        return node.hasAttribute('tabindex')? node.tabIndex : NaN
    }

    /**
     * @returns {String}
     */
    static get namespaceURI() {
        return XHTML_NAMESPACE_URI
    }

    /**
     * @returns {String}
     */
    static get localName() {
        return DEFAULT_HTML_ELEMENT_NAME
    }
}

/*================================================================*/

const { isArray, prototype : { forEach } } = Array

const ARIA_PREFIX = 'aria-'
const ARIA_PREFIX_LENGTH = ARIA_PREFIX.length

export class ARIADOMAssembler extends HTMLElementAssembler {
    init(init) {
        this.node.assembler = this
        this.className = this.role = this.constructor.role
        return super.init(init)
    }

    set role(role) {
        if(role) {
            role = isArray(role)? role.join(' ') : role
            this.node.setAttribute('role', role)
        }
        else this.node.removeAttribute('role')
    }

    get role() {
        return this.node.getAttribute('role') || ''
    }

    set aria(aria) {
        const node = this.node
        for(let name in aria) {
            const value = aria[name]
            if(typeof value === 'string') {
                node.setAttribute(ARIA_PREFIX + name, value)
            }
        }
    }

    get aria() {
        const aria = {}
        forEach.call(this.node.attributes, ({ name, value }) => {
            if(name.startsWith(ARIA_PREFIX)) {
                aria[name.slice(ARIA_PREFIX_LENGTH)] = value
            }
        })
        return aria
    }

    /**
     * @param {String} id unique identifier of the element
     */
    set id(id) {
        super.id = id
    }

    /**
     * @returns {String} unique identifier, autogenerated if need
     */
    get id() {
        return super.id || (this.id = this.constructor.uniqid)
    }

    /**
     * Generate unique identifier
     * @returns {String} unique id
     */
    static get uniqid() {
        let id
        do id = this.name + Math.floor(Math.random() * 1e10)
        while(document.getElementById(id))
        return id
    }

    /**
     * @returns {String}
     */
    static get role() {
        const getPrototypeOf = Object.getPrototypeOf
        let roleType = this
        let role = ''
        do if(roleType.abstract === false) role += ' ' + roleType.name
        while((roleType = getPrototypeOf(roleType)) && 'role' in roleType)
        return role.toLowerCase()
    }

    /**
     *
     * @returns {Boolean} is abstract role
     */
    static get abstract() {
        return true
    }
}
